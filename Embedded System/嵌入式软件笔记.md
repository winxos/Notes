# 嵌入式软件笔记
> wvv 20191216


[toc]

### STM32
#### STM32命名规则
#### STM32产品线
#### 常用MCU
##### STM32F103R8T6
##### STM32F103RCT6
#### 开发环境搭建
##### STM32CubeIDE
##### STM32CubeMonitor
##### ST-LINK Utility

### 模块调试经验

#### GY-49/max44009 I2C光照模块

```c
uint8_t data[2]={0,0};
HAL_I2C_Mem_Read(&hi2c1, 0x94, 0x03, I2C_MEMADD_SIZE_8BIT, data, 1, 0xff);
HAL_Delay(10);
HAL_I2C_Mem_Read(&hi2c1, 0x94, 0x04, I2C_MEMADD_SIZE_8BIT, &data[1], 1, 0xff);
int Exponent =  (data[0] & 0xF0) >> 4;
int Mantissa = ((data[0] & 0x0F) << 4) | (data[1] &0x0F);
int Lux = Mantissa * pow(2, Exponent)  * 0.045;
log_out(Lux);
```

注意:hal库中，地址需要乘以2，最低位是读写标志位。

### 相关技巧
#### 静态库编写和使用
#### FreeRTOS使用
#### RT-Thread使用
更详细内容请参考RT-Thread笔记
#### 项目文件结构规划
#### 中间件框架设计
#### 插件式系统框架设计

```c
static struct HLDevice * _find_last_device()
{
	struct HLDevice *p = hlib->devices;
	while (p->next != NULL)
	{
		p = p->next;
	}
	return p;
}
void hl_device_register(struct HLDevice *device)
{
	if (hlib->devices == NULL)
	{
		hlib->devices = device;
		return;
	}
	struct HLDevice *p = _find_last_device();
	p->next = device;
}
void hl_devices_init()
{
	struct HLDevice *p = hlib->devices;
	while (p)
	{
		if (p->ops->init)
		{
			p->ops->init(p->device);
		}
		p = p->next;
	}
}
void hl_devices_tick()
{
	struct HLDevice *p = hlib->devices;
	while (p)
	{
		if (p->ops->tick)
		{
			p->ops->tick(p->device);
		}
		p = p->next;
	}

}
void hl_devices_loop()
{
	struct HLDevice *p = hlib->devices;
	while (p)
	{
		if (p->ops->loop)
		{
			p->ops->loop(p->device);
		}
		p = p->next;
	}
}
```



#### 延时任务队列组件设计

``` c
struct HLTask
{
	pFunPtr action;	/*callback*/
	void* para;		/*parameter*/
	u32 cyc;		/*repeat task's cycle, once task if cyc equ 0*/
	u32 count;		/*the counter*/
	bool ready;		/*the ready flag*/
};

static struct HLArray *_tasks;
bool hl_tasks_add(pFunPtr f, void* para, u32 cyc, u32 count)
{
	struct HLTask * ptasks=(struct HLTask * )(_tasks->items);
	for (u8 i = 0; i<_tasks->lenth; i++)
	{
		if (NULL == ptasks[i].action)
		{
			ptasks[i].action = f;
			ptasks[i].para = para;
			ptasks[i].cyc = cyc;
			ptasks[i].count = count;
			ptasks[i].ready = FALSE;
			return TRUE;
		}
	}
	return FALSE;
}
bool hl_tasks_once_add(pFunPtr f, void* para, u32 count)
{
	return hl_tasks_add(f,para,0,count);
}
bool hl_tasks_delete(pFunPtr f)
{
	struct HLTask * ptasks=(struct HLTask * )(_tasks->items);
	for (u8 i = 0; i<_tasks->lenth; i++)
	{
		if (f == ptasks[i].action)
		{
			ptasks[i].action=NULL;
		}
	}
	return TRUE;
}
void hl_tasks_clear()
{
	struct HLTask * ptasks=(struct HLTask * )(_tasks->items);
	for (u8 i = 0; i < _tasks->lenth; i++)
	{
		ptasks[i].action=NULL;
	}
}
void hl_tasks_init(void *p)
{
	if(_tasks->items==NULL)
	{
		_tasks->lenth=(u32)p;
		hl_static_malloc_fetch(_tasks->lenth*sizeof(struct HLTask), _tasks->items);
	}
}
void hl_tasks_tick(void *p)
{
	if(_tasks==NULL || _tasks->items ==NULL)
	{
		return;
	}
	struct HLTask * ptasks=(struct HLTask * )(_tasks->items);
	for (u8 i = 0; i < _tasks->lenth; i++)
	{
		if (NULL != ptasks[i].action)
		{
			if (ptasks[i].count > 0)
			{
				ptasks[i].count--;
			}
			else
			{
				ptasks[i].ready = TRUE;
			}
		}
	}
}

void hl_tasks_loop(void *p)
{
	if(_tasks==NULL || _tasks->items ==NULL)
	{
		return;
	}
	struct HLTask * ptasks=(struct HLTask * )(_tasks->items);
	for (u8 i = 0; i < _tasks->lenth; i++)
	{
		if (NULL != ptasks[i].action)
		{
			if (TRUE == ptasks[i].ready)
			{
				ptasks[i].action(ptasks[i].para);
				if (((struct HLTask *)(_tasks->items))[i].cyc == 0)
				{
					/*one time task remove*/
					ptasks[i].action = NULL;
					ptasks[i].ready = FALSE;
				}
				else
				{
					/*reload task counter*/
					ptasks[i].count = ptasks[i].cyc;
					ptasks[i].ready = FALSE;
				}
			}
		}
	}
}

struct HLDeviceOps hl_tasks_ops={
		.init=hl_tasks_init,
		.tick=hl_tasks_tick,
		.loop=hl_tasks_loop
};
```



#### 业务流组件设计
``` c
void hl_workflow_to_last(pFunPtr dest, void *para)
{
    hlib->workflow->action=hlib->workflow->last;
    hlib->workflow->para=para;
    hlib->workflow->is_ready=TRUE;
}
void hl_workflow_set_next(pFunPtr dest, void *para)
{
    hlib->workflow->last=hlib->workflow->action;
    hlib->workflow->action=dest;
    hlib->workflow->para=para;
    hlib->workflow->is_ready=TRUE;
}
void hl_workflow_delay_set_next(pFunPtr dest, void *para,u32 d)
{
    hlib->workflow->last=hlib->workflow->action;
    hlib->workflow->action=dest;
    hlib->workflow->para=para;
    hlib->workflow->delay_ticks=d;
    hlib->workflow->is_ready=FALSE;
}
void hl_workflow_init(void *p)
{
	hlib->workflow=p;
}
void hl_workflow_tick(void *p)
{
	if(hlib->workflow->is_ready==FALSE)
	{
		if(hlib->workflow->delay_ticks>0)
		{
			hlib->workflow->delay_ticks--;
			if(hlib->workflow->delay_ticks==0)
			{
				hlib->workflow->is_ready=TRUE;
			}
		}
	}
}
void hl_workflow_loop(void *p)
{
	if(hlib->workflow->is_ready==TRUE)
	{
		hlib->workflow->is_ready=FALSE;
		if(hlib->workflow->action!=NULL)
		{
			hlib->workflow->action(hlib->workflow->para);
		}
	}
}
struct HLDeviceOps hl_workflow_ops={
		.init=hl_workflow_init,
		.tick=hl_workflow_tick,
		.loop=hl_workflow_loop
};

```
#### MODBUS主机组件设计

```c
void hl_modbus_master_send(struct HLModbusMaster *mmp,u8 *data, u16 len, pFunUart s, pFunPtr f)
{
	struct ModbusMsg m;
	memcpy(m.frame, data, len);
	m.len=len;
	m.success = s;
	m.fail = f;
	queue_push(&mmp->msgs, &m);
}
/*build master send frame*/
static u8* _build_frame(u8 addr, u8 func, u16 p1, u16 p2)
{
	u8 *tx_buf = hl_get_cache();
	tx_buf[0] = addr;
	tx_buf[1] = func;
	tx_buf[2] = p1 / 256;
	tx_buf[3] = p1 % 256;
	tx_buf[4] = p2 / 256;
	tx_buf[5] = p2 % 256;
	u16 crc16 = hl_modbus_crc(tx_buf, 6);
	tx_buf[6] = crc16 % 256;
	tx_buf[7] = crc16 / 256;
	return tx_buf;
}
/*03*/
void hl_modbus_master_read_registers(struct HLModbusMaster *mmp,u8 address, u16 start, u16 count,
		pFunUart success, pFunPtr fail)
{
	u8 *b = _build_frame(address, 0x03, start, count);
	hl_modbus_master_send(mmp,b, 8, success, fail);
}
/*05*/
void hl_modbus_master_write_coil(struct HLModbusMaster *mmp,u8 address, u16 start, u16 value,
		pFunUart success, pFunPtr fail)
{
	u8 *b = _build_frame(address, 0x05, start, value);
	hl_modbus_master_send(mmp,b, 8, success, fail);
}
/*06*/
void hl_modbus_master_write_register(struct HLModbusMaster *mmp,u8 address, u16 start, u16 value,
		pFunUart success, pFunPtr fail)
{
	u8 *b = _build_frame(address, 0x06, start, value);
	hl_modbus_master_send(mmp,b, 8, success, fail);
}
/*0x10*/
void hl_modbus_master_write_registers(struct HLModbusMaster *mmp,u8 address, u16 start, u16 count, u8* data,
		pFunUart success, pFunPtr fail)
{
	u8 *b = _build_frame(address, 0x10, start, count);
	u8 ds = count * 2;
	b[6] = ds;
	memcpy(&b[7], data, ds);
	u16 crc16 = hl_modbus_crc(b, 7 + ds);
	b[7 + ds] = crc16 % 256;
	b[8 + ds] = crc16 / 256;
	hl_modbus_master_send(mmp,b, 9 + ds, success, fail);
}

/*called by loop*/
static void hl_modbus_master_received(void *p,u8* buf, u32 len)
{
	struct HLModbusMaster *mmp= (struct HLModbusMaster *)p;
	if(len<4)
	{
		return;
	}
	if (mmp->current_msg.send_state == SS_SENDING)
	{
		if (buf[0] == mmp->current_msg.addr && buf[1] == mmp->current_msg.cmd)
		{
			mmp->current_msg.send_state = SS_RECEIVED;
			if (mmp->current_msg.success != NULL)
			{
				mmp->current_msg.success(mmp,buf,len);
			}
			mmp->current_msg.send_state = SS_IDLE;
		}
	}
}
void hl_modbus_master_init(void *p)
{
	struct HLModbusMaster *mmp=(struct HLModbusMaster *)p;
	mmp->serial.rx_cb.executor=hl_modbus_master_received;
	mmp->serial.rx_cb.device=mmp;
	queue_init(MODBUS_MASTER_QUEUE_SIZE, sizeof(struct ModbusMsg), &mmp->msgs, &mmp->msg_buf);
}
void hl_modbus_master_tick(void *p)
{
	struct HLModbusMaster *mmp=(struct HLModbusMaster *)p;
	if(mmp->current_msg.send_state==SS_SENDING)
	{
		if(mmp->current_msg.timeout==0)
		{
			mmp->current_msg.send_state=SS_TIMEOUT;
		}
		else
		{
			mmp->current_msg.timeout--;
		}
	}
}
void hl_modbus_master_loop(void *p)
{
	struct HLModbusMaster *mmp=(struct HLModbusMaster *)p;
	struct ModbusMsg m;
	switch(mmp->current_msg.send_state)
	{
	case SS_TIMEOUT:
		if (mmp->current_msg.fail != NULL)
		{
			mmp->current_msg.fail(0);
		}
		mmp->current_msg.send_state = SS_IDLE;
		break;
	case SS_IDLE:

		if (queue_peek(&mmp->msgs, &m) == TRUE)
		{
			queue_pop(&mmp->msgs, &m);
			mmp->current_msg.timeout=MODBUS_MASTER_TIMEOUT;
			mmp->current_msg.fail=m.fail;
			mmp->current_msg.success=m.success;
			mmp->current_msg.addr=m.frame[0];
			mmp->current_msg.cmd=m.frame[1];
			hl_serial_send(&mmp->serial,m.frame , m.len);
			mmp->current_msg.send_state = SS_SENDING;
			mmp->current_msg.send_state=SS_SENDING;
		}
		break;
	default:
		break;
	}
}
struct HLDeviceOps hl_modbus_master_ops={
		.init=hl_modbus_master_init,
		.tick=hl_modbus_master_tick,
		.loop=hl_modbus_master_loop
};
```



#### MODBUS从机组件设计

```c
struct ModbusMasterFrame
{
	u8 address;
	u8 function;
	u8 *data;
	u16 crc;
	u8 length;
};
bool drv_modbus_frame_valid(u8 *pbuf, u32 len)
{
	if (len < 4)
	{
		return FALSE;
	}
	u16 _check=pbuf[len - 1];
	_check= (_check << 8) + pbuf[len - 2];
	u16 crc = hl_modbus_crc(pbuf, len - 2);
	if (crc != _check)
	{
		return FALSE;
	}
	return TRUE;
}
/*f03*/
enum HLModbusRet drv_modbus_vm_read_registers(struct HLModbusSlave *ms,u16 addr, u16 size, u8 *out)
{
	u16 paddr=addr;
	u16* pout=(u16*)out;
	for (u8 i = 0; ms->registers[i].modbus_reg; i++)
	{
		struct HLModbusRegister *dr = &ms->registers[i];
		if(paddr<dr->start_address)
		{
			break;
		}
		if ((paddr >= dr->start_address) && (paddr < (dr->start_address + dr->length)))
		{
			if(dr->read==NULL)
			{
				return M_INVALID_AUTHORITY;
			}
			dr->read(dr->modbus_reg,dr->device);
			while((paddr >= dr->start_address) && (paddr < (dr->start_address + dr->length)))
			{
				*pout=*(dr->modbus_reg + paddr - dr->start_address);
				pout++;
				paddr++;
				if(paddr-addr>=size)
				{
					return M_OK;
				}
			}
		}
	}
	return M_INVALID_ADDRESS;
}
/*f06*/
enum HLModbusRet drv_modbus_vm_write_register(struct HLModbusSlave *ms,u16 addr, u16 d)
{
	for (u8 i = 0; ms->registers[i].modbus_reg; i++)
	{
		struct HLModbusRegister *dr = &ms->registers[i];
		if (dr != NULL && dr->modbus_reg != NULL)
		{
			if ((addr >= dr->start_address) && (addr < (dr->start_address + dr->length)))
			{
				if(dr->write==NULL)
				{
					return M_INVALID_AUTHORITY;
				}
				dr->modbus_reg[addr - dr->start_address] = d;
				dr->write(dr->modbus_reg,dr->device);
				return M_OK;
			}
		}
	}
	return M_INVALID_ADDRESS;
}
/*f10*/
enum HLModbusRet drv_modbus_vm_write_registers(struct HLModbusSlave *ms,u16 addr, u16 len, u8 * data)
{
	for (u8 i = 0; ms->registers[i].modbus_reg; i++)
	{
		struct HLModbusRegister *dr = &ms->registers[i];
		if (dr != NULL && dr->modbus_reg != NULL)
		{
			if ((addr >= dr->start_address) && (addr < (dr->start_address + dr->length)))
			{
				if(dr->write==NULL)
				{
					return M_INVALID_AUTHORITY;
				}
				memcpy(&dr->modbus_reg[addr - dr->start_address],data,len);
				dr->write(dr->modbus_reg,dr->device);
				return M_OK;
			}
		}
	}
	return M_INVALID_ADDRESS;
}
/*f11*/
enum HLModbusRet drv_modbus_vm_read_id(u8 *out, u16 *len)
{
	return M_OK;
}
void drv_modbus_rx_analyze(void *p,u8 *_rx_buf, u32 _rx_count)
{
	struct HLModbusSlave *ms=(struct HLModbusSlave *)p;
	if(_rx_buf[0]!=ms->address)/*not support broadcast*/
	{
		return;
	}
	if(drv_modbus_frame_valid(_rx_buf,_rx_count)==FALSE)
	{
		return;
	}
	u16 addr, size, value, len;
	struct ModbusMasterFrame _mmf;
	_mmf.address = _rx_buf[0];
	_mmf.function = _rx_buf[1];
	_mmf.data = &_rx_buf[2];
	addr = ((u16) _mmf.data[0] << 8) + _mmf.data[1];
	value = ((u16) _mmf.data[2] << 8) + _mmf.data[3];
	switch (_mmf.function)
	{
	case 0x03:/*read registers*/
		size = value;
		if (drv_modbus_vm_read_registers(ms,addr, size, &_rx_buf[3]) == M_OK)
		{
			_rx_buf[2] = size*2;
			u16 t = hl_modbus_crc(_rx_buf, 3 + size * 2);
			_rx_buf[2 * size + 3] = t & 0x00ff;
			_rx_buf[2 * size + 4] = t >> 8;
			hl_serial_send(&ms->serial, _rx_buf, 2 * size + 5);
		}
		break;
	case 0x06:/*write register*/
		if (drv_modbus_vm_write_register(ms,addr, value) == M_OK)
		{
			hl_serial_send(&ms->serial, _rx_buf, 8);
		}
		break;
	case 0x10:/*write registers*/
		len =  _mmf.data[4];
		if (drv_modbus_vm_write_registers(ms,addr, len,&_mmf.data[5]) == M_OK)
		{
			u16 t = hl_modbus_crc(_rx_buf, 6);
			_rx_buf[6] = t & 0x00ff;
			_rx_buf[7] = t >> 8;
			hl_serial_send(&ms->serial, _rx_buf, 8);
		}
		break;
	default:
		break;
	}
}
void hl_modbus_slave_init(void *p)
{
	struct HLModbusSlave *msp=(struct HLModbusSlave *)p;
	msp->serial.rx_cb.executor=drv_modbus_rx_analyze;
	msp->serial.rx_cb.device=msp;
}
struct HLDeviceOps hl_modbus_slave_ops={
		.init=hl_modbus_slave_init
};
```



#### 虚拟总线层设计
#### ITM调试系统设计
``` c
static void _itm_log(u8 *d,u32 len)
{
	while(len--)
	{
		ITM_SendChar(*(d++));
	}
}
void hl_log(char *s)
{
	u8 buf[80];
	int len=sprintf((char*)buf, "[D][%8ld]%s\n", HAL_GetTick(), s);
	_itm_log(buf,len);
}
```
#### 可靠串口bsp实现

```c
void hl_uart_send(struct HLUart *up,u8* data,u32 len)
{
	HAL_UART_Transmit(up->huart, data, len, 0xffff);/*block sending*/
}
void hl_uart_irq(struct HLUart *up)
{
	__HAL_UART_CLEAR_IDLEFLAG((UART_HandleTypeDef*)up->huart);
	HAL_UART_DMAStop(up->huart);
	up->rx_buf.len = HL_MSG_SIZE - __HAL_DMA_GET_COUNTER(((UART_HandleTypeDef*)up->huart)->hdmarx);
	xQueueSendFromISR(up->rxq, &up->rx_buf, NULL);
}
HLUartOps _uart_ops={
		.interrupt=hl_uart_irq,
		.write=hl_uart_send
};
/*
 * create freertos queue,
 * because freertos's inner macro osMessageQDef and osMessageQ using ## symbol,
 * so you cann't pass variables through osMessageQDef or osMessageQ,
 * this macro combine the queue create procedure,
 * HANDLE is queue handle
 * SZ is the size you need
 * TYPE is the data type
 * N is the name
 * */
#define HL_QUEUE_INIT(HANDLE,SZ,TYPE,N) do{\
	osMessageQDef(N, SZ, TYPE);\
	HANDLE=osMessageCreate(osMessageQ(N), NULL);\
	}while(0)
/*
 * create unique name freertos queue,
 * using inner macro __COUNTER__ to create unique named queue each time you called,
 * HANDLE is queue handle
 * SZ is the size you need
 * TYPE is the data type
 * */
#define HL_QUEUE_INIT_UNIQUE(HANDLE,SZ,TYPE) HL_QUEUE_INIT(HANDLE,SZ,TYPE,__COUNTER__)

void hl_uart_init(void *p)
{
	struct HLUart *huart=(struct HLUart*)p;
	HL_QUEUE_INIT_UNIQUE(huart->rxq,3,struct HLMsg);/*it's very very hard to implementation*/
	HL_QUEUE_INIT_UNIQUE(huart->txq,2,struct HLMsg);
	__HAL_UART_ENABLE_IT((UART_HandleTypeDef*)huart->huart,UART_IT_IDLE);
	HAL_UART_Receive_DMA((UART_HandleTypeDef*)huart->huart,huart->rx_buf.data, HL_MSG_SIZE);
}
void hl_uart_loop(void *p)
{
	struct HLUart *up=(struct HLUart *)p;
	struct HLMsg t;
	if (xQueueReceive(up->rxq,&t,0) == pdTRUE)/*received queue*/
	{
		HAL_UART_Receive_DMA((UART_HandleTypeDef*)up->huart, up->rx_buf.data, HL_MSG_SIZE);
		struct HLFunLink * p=up->rxlist;
		while(p!=NULL)
		{
			p->executor(p->device,t.data, t.len);/*call callback link*/
			p=p->next;
		}
	}
	if (xQueueReceive(up->txq,&t,0) == pdTRUE)/*send queue*/
	{
		hl_uart_send(up, t.data, t.len);
		struct HLFunLink * p=up->txlist;
		while(p!=NULL)
		{
			p->executor(p->device,t.data, t.len);/*call callback link*/
			p=p->next;
		}
	}
}
struct HLDeviceOps uart_device_ops;
```



#### IAP系统设计
#### 微量级文件系统设计

```c
bool hl_file_table_mount()
{
//	hl_flash_read(FILE_TABLE_ADDRESS+sizeof(struct HLfat)/4,
//			(u32*)f,sizeof(struct HLfat)/4);
//	u32 check=hl_modbus_crc((u8*)f, sizeof(struct HLfat)-4);
//	if(check!=f->check)
//	{
//		return FALSE;
//	}
	return TRUE;
}
void hl_file_table_save()
{
//	hl_flash_page_erase(FILE_TABLE_ADDRESS);
//	u32 addr=FILE_TABLE_ADDRESS+sizeof(struct HLfat)/4;
//	u32 check=hl_modbus_crc((u8*)&_fs, sizeof(struct HLfat)-4);
//	_fs.check=check;
//	hl_flash_write(addr, (u32*)_fs, sizeof(struct HLfat)/4);
}
HLFile* hl_file_create(char *name,u16 item_size,u16 item_count)
{
	HLFile* f=hlib->fat->files;
	for(u8 i=0;i<FILE_MAX_COUNT;i++)
	{
		if(strlen(f->name)==0) /*blank file, allocate to this*/
		{
			memcpy(f->name,name,strlen(name));
			f->item_count=item_count;
			f->item_dwsize=item_size;
			f->start_sector=hlib->fat->sector_used;
			f->items_per_sector=hlib->fat->sector_size/(f->item_dwsize*4);
			f->item_index=-1;
			hl_file_table_save();/*new file add, save file table*/
			return f;
		}
		else if(strcmp(f->name,name)==0) /*name repeat*/
		{
			return NULL;
		}
		else /*other file*/
		{
			hlib->fat->sector_used+=1+(f->item_count-1)/f->items_per_sector;
		}
		f++;
	}
	return NULL;
}
HLFile * hl_file_open(char *name)
{
	HLFile* f=hlib->fat->files;
	for(u8 i=0;i<FILE_MAX_COUNT;i++)
	{
		if(strcmp(f->name,name)==0)
		{
			return f;
		}
		f++;
	}
	return NULL;
}
static inline u32 _file_get_current_sector_address(HLFile *f)
{
	return hlib->fat->table_address+
			(1+f->start_sector+f->item_index/f->items_per_sector)*hlib->fat->sector_size;
}
static inline u32 _file_get_a_item_address(HLFile *f,u16 index)
{
	return hlib->fat->table_address+
			(1+f->start_sector+index/f->items_per_sector)*hlib->fat->sector_size+
			(index%f->items_per_sector)*f->item_dwsize*4;
}

bool hl_file_read(HLFile *f,u32 *buf,u32 len,u32 index)
{
	if(index<0 || index>=f->total_write_count || index>=f->item_count)
	{
		return FALSE;
	}
	hlib->flash->read(_file_get_a_item_address(f,index),buf,f->item_dwsize);
	return TRUE;
}
bool hl_file_write(HLFile *f,u32 *buf,u32 len)
{
	f->item_index++;
	if(f->item_index==f->item_count)
	{
		f->item_index=0;
	}
	if(f->item_index%f->items_per_sector==0)/*new sector*/
	{
		hlib->flash->erase(_file_get_current_sector_address(f));
	}
	u32 addr=_file_get_a_item_address(f,f->item_index);
	hlib->flash->write(addr,buf,f->item_dwsize);
	f->total_write_count++;
	hl_file_table_save();
	return TRUE;
}

HLFileOps hl_file_ops={
		.create=hl_file_create,
		.open=hl_file_open,
		.read=hl_file_read,
		.write=hl_file_write
};
```