# C语言笔记
> wvv 20200315

[toc]
### 数据类型
#### 常见数据类型

在不同类型系统上，不同类型所占宽度不同，在32位系统上

* 整型

| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| -------------- | ----------- | ---------------------------------------------------- |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

* 浮点型

| float       | 4 字节  | 1.2E-38 到 3.4E+38     | 6 位小数  |
| ----------- | ------- | ---------------------- | --------- |
| double      | 8 字节  | 2.3E-308 到 1.7E+308   | 15 位小数 |
| long double | 16 字节 | 3.4E-4932 到 1.1E+4932 | 19 位小数 |

* void类型

 void 类型表明没有可用值。 

* void*类型

 void *类型，代表任何类型的指针，可以强制转换为任何指针类型。 

#### 数组

##### 多维数组

`int  a[2][2][3]={{{1},{2}},{{3},{4}}};`

也可以用下标进行初始化

`int  a[2][2][3]={1,[0][1][0]=5,[1][1][2]=8};`

也可以用下标进行初始化

`int  a[2][2][3]={{1},[0][1]={5,2},[1][0]={2,4}};`

##### 指针数组

指针数组的实质就是一个数组，数组中存的所有元素是指针变量。 

` int *p[5]; `

因为运算符[]优先级比 * 要高，所以p先和[]结合，所以p是一个数组，指向的类型是int *

所以`sizeof(p)` 会得到5倍int的大小。


##### 数组指针

数组指针的实质是一个指针，指向的是一个数组。 

` int (*p)[5];`

因为运算符()所以p先和 * 结合，所以p是一个指针，指向了一个int数组。

所以`sizeof(p)`会得到指针自身长度。

#### 结构体

* 声明

```c
struct St
{
    int a;
    char b;
};
struct St st={1,'a'};
```

c语言中，每次使用结构体都需要带struct前缀，可以使用typedef来简化

```c
typedef struct
{
    int a;
    char b;
}  St;
```

上面实际上利用typedef声明了一个匿名结构体，然后加上struct前缀合成了St，以后所有使用结构体的地方都不需要加Struct的前缀。

虽然采用typedef的的方式简化了书写，但是一般不推荐这种做法，某些特殊的情况下容易引起混乱。

* 初始化

```c
struct St st1={1,'a'};
struct St st2={.a = 1};
```

上面提供了两种不同方式的初始化

* 嵌套

结构体内部可以包含其他结构体，也可以包含自身的结构体指针，这个特性是链表等数据结构的基础。

```c
struct Node
{
    int a;
    struct Node *next;
};
```

* 不完整声明

如果两个结构体需要嵌套，则需要对其中一个进行不完整声明

```c
struct B;
struct A
{
    struct B *p;
};
struct B
{
    struct A *p;
};
```

* 结构体作为参数

可以通过传值或传指针的方式将结构体传入函数

```c
void f1( struct St s );
void f2( struct St *s );
```

结构体数组通过指针的方式进行参数传入。

* 位域

位域或者位段，是把一个字节划分成不同的区域，达到节省空间的一种手段，这在硬件资源匮乏的嵌入式领域是一种常用的技巧。位域宽度不能大于8。

```c
struct St{
    int a:4;
    int b:2;
    int c:2;
}
```

上述结构体实际上只占用了一个int的大小。

```c
struct St{
    int a:4;
    int  :2;
    int c:2;
}
```

位域中的变量可以是无名位域，这些空间会默认填充为0，一般起到填充对齐的作用，上述代码进行了演示。

#### 枚举

枚举一般用于常量的定义，可以增加代码可读性。

```c
enum Day
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum Day day;
```

枚举可以定义成不连续分配

```c
enum Ms
{
    M1,
    M2 = 10,
    M3
};
```

整形转换成枚举时需要进行强制转换。

#### 字符串
#### 指针
指针是一个变量，其值为另一个变量的地址
NULL 指针是一个定义在标准库中的值为零的常量，为指针变量赋一个 NULL 值是一个良好的编程习惯。
##### 指针算术运算
可以对指针进行四种算术运算：++、--、+、-。
指针可以用关系运算符进行比较，如 ==、< 和 >。
指针在递增和递减时地址的变化取决于指针所指向变量数据类型长度。
##### 函数指针
函数指针是指向函数的指针变量。
`int (* p)(int, int);`
声明了带两个int参数的返回值也为int的函数指针p，注意小括号将 * 和 p 括起来。
可以通过 `typedef`来定义函数指针的别名，可以简化书写。
```c
typedef int (* pF)(int, int);
pF fun;
```
可以将函数指针传入函数，从而构成回调函数。
```c
int add(int a, int b)
{
    return a+b;
}
int calc(pF f, int a, int b)
{
    return f(a, b);
}
calc(add, 1, 2);
```
函数指针数组可以如下声明
```c
int (* pF[10])(int, int);
```
或者
```c
typedef int (* pF)(int, int);
pF fun[10];
```
很明显后者更清晰，方便。
##### 数组名与指向数组的指针的关系

* 相同点：

数组名和指向数组的指针都指向的是数组中第一个元素的地址。

都可以通过下标或者指针的方式访问。

* 不同点

数组名是常量指针，不能再次赋值。

普通指针是变量指针，可以随时修改指向。

对数组名利用&取地址时等价于不用&符号，意味着&符号对数组名操作时可以省略。

对指针利用&取地址时得到的是指针自身存储的地址。

数组名进行加1操作时，得到的偏移量是整个数组的大小。

对指针进行加1操作时，得到的偏移量只是单个元素的大小。

* 示例代码

```c
#include <stdio.h>
int main() {
    int a[]={1,2,3};
    int *pa =a;
    printf("%p %p %p\n",a,&a,&a[0]);
    printf("%p %p\n",pa,&pa);
    printf("%p %p\n",&a+1,pa+1);
    printf("%d %d %d\n",sizeof(a),sizeof(pa),sizeof(*pa));
    return 0;
}
```

**输出结果**

```
000000000065FE14 000000000065FE14 000000000065FE14
000000000065FE14 000000000065FE08
000000000065FE20 000000000065FE18
12 8 4
```

**结果分析**

`printf("%p %p %p\n",a,&a,&a[0]);`

输出内容都为 000000000065FE14 说明对数组名来讲，a,&a,&a[0]表示的都是第一个元素的地址

`printf("%p %p\n",pa,&pa);`

输出内容pa,&pa不同，分别表示了指针其指向的地址和自身的地址。

`printf("%p %p\n",&a+1,pa+1);`

输出内容相对元素首地址来讲，&a+1 增加了12字节，pa+1增加了4字节，这个是跟他们指向内容表示大小有关，他们指向内容的大小可以通过sizeof得到，结合下句

初始声明

```c
    int a[]={1,2,3};
    int *pa =a;
```

以及 `printf("%d %d %d\n",sizeof(a),sizeof(pa),sizeof(*pa));`输出12 8 4，表明了：

1. sizeof(a)得到了数组常量指向的宽度，是整个数组的大小
2. sizeof(pa)表示的是指针pa自身的大小（我的系统是64位，所以指针类型都是64位即8字节大小）
3. sizeof(*pa)表示的是指针所指向的内容的大小，即第一个int型元素的大小

### 可变参数

c语言中，可以通过三个点 ... 的方式声明参数，实现可变个数参数的输入。

像printf函数就是用这种方式实现的。

需要包含头文件 `#include <stdarg.h>`

```c
int f(int num, ... ) 
{
   ...
}
 
```

 **va_list**  

 **va_start**  

 **va_arg**  

 **va_end**  

需要用到上述几个宏。

c语言中需要用到此技巧的地方不多，真的有这个需求的时候再自行查阅更详细资料。



### 宏和预处理

### 内存分配

### 头文件包含

### 数据结构

#### 抽象数据类型ADT

#### 链表
#### 队列
#### 二叉树
### OOP